{
  "language": "Solidity",
  "sources": {
    "src/Arbitrator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.15;\n\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { SafeTransferLib } from \"solmate/src/utils/SafeTransferLib.sol\";\n\nimport { IArbitrable } from \"./interfaces/IArbitrable.sol\";\nimport { IArbitrator } from \"./interfaces/IArbitrator.sol\";\n\nimport { PositionParams } from \"./lib/AgreementStructs.sol\";\nimport { Resolution, ResolutionStatus } from \"./lib/ResolutionStructs.sol\";\nimport { Controlled } from \"./lib/auth/Controlled.sol\";\nimport { FeeCollector } from \"./lib/FeeCollector.sol\";\nimport { Toggleable } from \"./lib/Toggleable.sol\";\nimport { Permit } from \"./lib/Permit.sol\";\n\n/// @notice Contract with the power to arbitrate Nation3 agreements.\n/// @dev The DAO will be expected to own this contract and set a controller to operate it.\n/// @dev The owner set the working parameters and manage the fees.\n/// @dev The owner can disable submissions and executions at any moment.\n/// @dev The owner can replace the controller at any time.\n/// @dev Only parties of a resolution can appeal the resolution.\n/// @dev The owner can override appeals by backing resolutions.\n/// @dev Everyone can execute non-appealed resolutions after a locking period.\ncontract Arbitrator is IArbitrator, Controlled(msg.sender, msg.sender), Toggleable, FeeCollector {\n    /// @dev Number of blocks needed to wait before executing a resolution.\n    uint256 public executionLockPeriod;\n\n    /// @dev Mapping of all submitted resolutions.\n    mapping(bytes32 => Resolution) public resolution;\n\n    /// @notice Setup arbitrator variables.\n    /// @param feeToken_ Token used to pay arbitration costs.\n    /// @param fee_ Fee cost.\n    /// @param executionLockPeriod_ Number of blocks needed to wait before executing a resolution.\n    /// @param enabled_ Status of the arbitrator.\n    function setUp(\n        ERC20 feeToken_,\n        uint256 fee_,\n        uint256 executionLockPeriod_,\n        bool enabled_\n    ) external onlyOwner {\n        _setFee(feeToken_, address(this), fee_);\n        executionLockPeriod = executionLockPeriod_;\n        enabled = enabled_;\n    }\n\n    /// @inheritdoc Toggleable\n    /// @dev Allows owner to disable submissions and executions.\n    function setEnabled(bool status) external override onlyOwner {\n        enabled = status;\n    }\n\n    /// @inheritdoc FeeCollector\n    /// @dev Allows owner to update the arbitration fees.\n    function setFee(\n        ERC20 token,\n        address recipient,\n        uint256 amount\n    ) external override onlyOwner {\n        _setFee(token, recipient, amount);\n    }\n\n    /// @notice Withdraw ERC20 tokens from the contract.\n    function withdrawTokens(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) external onlyOwner {\n        _withdraw(token, to, amount);\n    }\n\n    /// @inheritdoc IArbitrator\n    /// @dev Only controller is able to submit resolutions.\n    function submitResolution(\n        IArbitrable framework,\n        bytes32 id,\n        string calldata metadataURI,\n        PositionParams[] calldata settlement\n    ) public isEnabled onlyController returns (bytes32) {\n        bytes32 hash = _resolutionHash(address(framework), id);\n        Resolution storage resolution_ = resolution[hash];\n\n        if (resolution_.status == ResolutionStatus.Executed) revert ResolutionIsExecuted();\n\n        resolution_.status = ResolutionStatus.Pending;\n        resolution_.mark = keccak256(abi.encode(settlement));\n        resolution_.metadataURI = metadataURI;\n        resolution_.unlockBlock = block.number + executionLockPeriod;\n\n        emit ResolutionSubmitted(address(framework), id, hash);\n\n        return hash;\n    }\n\n    /// @inheritdoc IArbitrator\n    function executeResolution(\n        IArbitrable framework,\n        bytes32 id,\n        PositionParams[] calldata settlement\n    ) public isEnabled {\n        bytes32 hash = _resolutionHash(address(framework), id);\n        Resolution storage resolution_ = resolution[hash];\n\n        if (resolution_.status == ResolutionStatus.Appealed) revert ResolutionIsAppealed();\n        if (resolution_.status == ResolutionStatus.Executed) revert ResolutionIsExecuted();\n        if (\n            resolution_.status != ResolutionStatus.Endorsed &&\n            block.number < resolution_.unlockBlock\n        ) revert ExecutionStillLocked();\n        if (resolution_.mark != keccak256(abi.encode(settlement))) revert ResolutionMustMatch();\n\n        framework.settleDispute(id, settlement);\n\n        resolution_.status = ResolutionStatus.Executed;\n\n        emit ResolutionExecuted(hash);\n    }\n\n    /// @inheritdoc IArbitrator\n    function appealResolution(bytes32 hash, PositionParams[] calldata settlement) external {\n        _canAppeal(msg.sender, hash, settlement);\n\n        SafeTransferLib.safeTransferFrom(feeToken, msg.sender, address(this), fee);\n\n        resolution[hash].status = ResolutionStatus.Appealed;\n\n        emit ResolutionAppealed(hash, msg.sender);\n    }\n\n    /// @inheritdoc IArbitrator\n    function appealResolutionWithPermit(\n        bytes32 hash,\n        PositionParams[] calldata settlement,\n        Permit calldata permit\n    ) external {\n        _canAppeal(msg.sender, hash, settlement);\n\n        feeToken.permit(\n            msg.sender,\n            address(this),\n            permit.value,\n            permit.deadline,\n            permit.v,\n            permit.r,\n            permit.s\n        );\n        SafeTransferLib.safeTransferFrom(feeToken, msg.sender, address(this), fee);\n\n        resolution[hash].status = ResolutionStatus.Appealed;\n\n        emit ResolutionAppealed(hash, msg.sender);\n    }\n\n    /// @inheritdoc IArbitrator\n    function endorseResolution(bytes32 hash, PositionParams[] calldata settlement)\n        external\n        onlyOwner\n    {\n        Resolution storage resolution_ = resolution[hash];\n\n        if (resolution_.status == ResolutionStatus.Default) revert ResolutionNotSubmitted();\n        if (resolution_.status == ResolutionStatus.Executed) revert ResolutionIsExecuted();\n        if (resolution_.mark != keccak256(abi.encode(settlement))) revert ResolutionMustMatch();\n\n        resolution_.status = ResolutionStatus.Endorsed;\n\n        emit ResolutionEndorsed(hash);\n    }\n\n    /* ====================================================================== */\n    /*                              INTERNAL UTILS\n    /* ====================================================================== */\n\n    /// @dev Get resolution hash for given dispute.\n    /// @param framework address of the framework of the agreement in dispute.\n    /// @param id identifier of the agreement in dispute.\n    function _resolutionHash(address framework, bytes32 id) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(framework, id));\n    }\n\n    /// @dev Check if account can appeal a resolution.\n    /// @param account address to check.\n    /// @param hash hash of the resolution.\n    function _canAppeal(\n        address account,\n        bytes32 hash,\n        PositionParams[] calldata settlement\n    ) internal view {\n        Resolution storage resolution_ = resolution[hash];\n\n        if (resolution_.status == ResolutionStatus.Default) revert ResolutionNotSubmitted();\n        if (resolution_.status == ResolutionStatus.Executed) revert ResolutionIsExecuted();\n        if (resolution_.status == ResolutionStatus.Endorsed) revert ResolutionIsEndorsed();\n        if (resolution_.mark != keccak256(abi.encode(settlement))) revert ResolutionMustMatch();\n        if (!_isParty(account, settlement)) revert NoPartOfResolution();\n    }\n\n    /// @dev Check if an account is part of a settlement.\n    /// @param account Address to check.\n    /// @param settlement Array of positions.\n    function _isParty(address account, PositionParams[] calldata settlement)\n        internal\n        pure\n        returns (bool found)\n    {\n        for (uint256 i = 0; !found && i < settlement.length; i++) {\n            if (settlement[i].party == account) found = true;\n        }\n    }\n}\n"
    },
    "src/interfaces/IArbitrator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.15;\n\nimport { PositionParams } from \"../lib/AgreementStructs.sol\";\nimport { Permit } from \"../lib/Permit.sol\";\nimport { IArbitrable } from \"./IArbitrable.sol\";\n\ninterface IArbitrator {\n    event ResolutionSubmitted(address indexed framework, bytes32 indexed id, bytes32 indexed hash);\n    event ResolutionAppealed(bytes32 indexed hash, address account);\n    event ResolutionEndorsed(bytes32 indexed hash);\n    event ResolutionExecuted(bytes32 indexed hash);\n\n    error ResolutionNotSubmitted();\n    error ResolutionIsAppealed();\n    error ResolutionIsExecuted();\n    error ResolutionIsEndorsed();\n    error ExecutionStillLocked();\n    error ResolutionMustMatch();\n    error NoPartOfResolution();\n\n    /// @notice Submit a resolution for a dispute.\n    /// @dev Any new resolution for the same dispute overrides the last one.\n    /// @param framework address of the framework of the agreement in dispute.\n    /// @param id identifier of the agreement in dispute.\n    /// @param settlement Array of final positions in the resolution.\n    /// @return Hash of the resolution submitted.\n    function submitResolution(\n        IArbitrable framework,\n        bytes32 id,\n        string calldata metadataURI,\n        PositionParams[] calldata settlement\n    ) external returns (bytes32);\n\n    /// @notice Execute a submitted resolution.\n    /// @param framework address of the framework of the agreement in dispute.\n    /// @param id identifier of the agreement in dispute.\n    /// @param settlement Array of final positions in the resolution.\n    function executeResolution(\n        IArbitrable framework,\n        bytes32 id,\n        PositionParams[] calldata settlement\n    ) external;\n\n    /// @notice Appeal a submitted resolution.\n    /// @param hash Hash of the resolution to appeal.\n    /// @param settlement Array of final positions in the resolution.\n    function appealResolution(bytes32 hash, PositionParams[] calldata settlement) external;\n\n    /// @notice Appeal a submitted resolution with EIP-2612 permit.\n    /// @param hash Hash of the resolution to appeal.\n    /// @param settlement Array of final positions in the resolution.\n    /// @param permit EIP-2612 permit data to approve transfer of tokens.\n    function appealResolutionWithPermit(\n        bytes32 hash,\n        PositionParams[] calldata settlement,\n        Permit calldata permit\n    ) external;\n\n    /// @notice Endorse a submitted resolution so it can't be appealed.\n    /// @param hash Hash of the resolution to endorse.\n    /// @param settlement Array of final positions in the resolution.\n    function endorseResolution(bytes32 hash, PositionParams[] calldata settlement) external;\n}\n"
    },
    "lib/solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "lib/solmate/src/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"
    },
    "src/interfaces/IArbitrable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.15;\nimport { PositionParams } from \"../lib/AgreementStructs.sol\";\n\n/// @notice Interface for arbitrable contracts.\n/// @dev Implementers must write the logic to raise and settle disputes.\ninterface IArbitrable {\n    error OnlyArbitrator();\n\n    /// @notice Address capable of settling disputes.\n    function arbitrator() external view returns (address);\n\n    /// @notice Settles a dispute providing settlement positions.\n    /// @param id Id of the dispute to settle.\n    /// @param settlement Array of final positions.\n    function settleDispute(bytes32 id, PositionParams[] calldata settlement) external;\n}\n"
    },
    "src/lib/AgreementStructs.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.15;\n\nenum AgreementStatus {\n    Created,\n    Ongoing,\n    Finalized,\n    Disputed\n}\n\nenum PositionStatus {\n    Idle,\n    Joined,\n    Finalized\n}\n\n/// @dev Agreement party position\nstruct Position {\n    /// @dev Matches index of the party in the agreement\n    uint256 id;\n    /// @dev Amount of tokens corresponding to this position.\n    uint256 balance;\n    /// @dev Status of the position\n    PositionStatus status;\n}\n\nstruct Agreement {\n    /// @dev Hash of the detailed terms of the agreement.\n    bytes32 termsHash;\n    /// @dev Required amount to join or merkle root of (address,amount).\n    uint256 criteria;\n    /// @dev URI of the metadata of the agreement.\n    string metadataURI;\n    /// @dev Total amount of collateral tokens deposited in the agreement.\n    uint256 balance;\n    /// @dev Number of finalizations confirmations.\n    uint256 finalizations;\n    /// @dev Signal if agreement is disputed.\n    bool disputed;\n    /// @dev List of parties involved in the agreement.\n    address[] party;\n    /// @dev Position by party.\n    mapping(address => Position) position;\n}\n\n/// @dev Adapter of agreement params for functions I/O.\nstruct AgreementParams {\n    /// @dev Hash of the detailed terms of the agreement.\n    bytes32 termsHash;\n    /// @dev Required amount to join or merkle root of (address,amount).\n    uint256 criteria;\n    /// @dev URI of the metadata of the agreement.\n    string metadataURI;\n}\n\n/// @dev Params to create new positions.\nstruct PositionParams {\n    /// @dev Holder of the position.\n    address party;\n    /// @dev Amount of tokens corresponding to this position.\n    uint256 balance;\n}\n\n/// @dev Agreement position data.\nstruct AgreementPosition {\n    /// @dev Holder of the position.\n    address party;\n    /// @dev Amount of tokens corresponding to this position.\n    uint256 balance;\n    /// @dev Status of the position.\n    PositionStatus status;\n}\n"
    },
    "src/lib/FeeCollector.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.15;\n\nimport { ERC20 } from \"solmate/src/tokens/ERC20.sol\";\nimport { SafeTransferLib } from \"solmate/src/utils/SafeTransferLib.sol\";\n\n\n/// @notice Simple mixin to setup and collect fees.\nabstract contract FeeCollector {\n\n    /// @dev Token used to collect fees.\n    ERC20 public feeToken;\n\n    /// @dev Default fee recipient.\n    address public feeRecipient;\n\n    /// @dev Amount of tokens to collect as fee.\n    uint256 public fee;\n\n    /// @dev Raised when the recipient is not valid.\n    error InvalidRecipient();\n\n    /// @notice Withdraw any fees in the contract to the default recipient.\n    function collectFees() external virtual {\n        if (feeRecipient == address(0)) revert InvalidRecipient();\n\n        uint256 amount = feeToken.balanceOf(address(this));\n        _withdraw(feeToken, feeRecipient, amount);\n    }\n\n    /// @notice Set fee parameters.\n    /// @param token ERC20 token to collect fees with.\n    /// @param recipient Default recipient for the fees.\n    /// @param amount Amount of fee tokens per fee.\n    function setFee(ERC20 token, address recipient, uint256 amount) external virtual {\n        _setFee(token, recipient, amount);\n    }\n\n    /// @dev Withdraw ERC20 tokens from the contract.\n    function _withdraw(ERC20 token, address to, uint256 amount) internal virtual {\n        SafeTransferLib.safeTransfer(token, to, amount);\n    }\n\n    /// @dev Set fee parameters.\n    function _setFee(ERC20 token, address recipient, uint256 amount) internal {\n        if (recipient == address(0)) revert InvalidRecipient();\n\n        feeToken = token;\n        feeRecipient = recipient;\n        fee = amount;\n    }\n\n}\n"
    },
    "src/lib/Permit.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.15;\n\n/// @dev EIP-2612 Permit\n///      Together with a EIP-2612 compliant token,\n///      allows a contract to approve transfer of funds through signature.\n///      This is specially usefull to implement operations \n///      that approve and transfer funds on the same transaction.\nstruct Permit {\n    uint256 value;\n    uint256 deadline;\n    /// ECDSA Signature components.\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n}\n\n\n"
    },
    "src/lib/ResolutionStructs.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.15;\n\nenum ResolutionStatus {\n    Default,\n    Pending,\n    Endorsed,\n    Appealed,\n    Executed\n}\n\nstruct Resolution {\n    ResolutionStatus status;\n    bytes32 mark;\n    string metadataURI;\n    uint256 unlockBlock;\n}\n\n\n"
    },
    "src/lib/Toggleable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.15;\n\n/// @notice Simple mixin to enable / disable a contract.\nabstract contract Toggleable {\n\n    error IsDisabled();\n\n    /// @dev Set status of the arbitrator.\n    bool public enabled;\n\n    /// @dev Requires to be enabled before performing function.\n    modifier isEnabled() {\n        if (!enabled) revert IsDisabled();\n        _;\n    }\n\n    /// @notice Enable / disable a contract.\n    /// @param status New enabled status.\n    function setEnabled(bool status) external virtual {\n        enabled = status;\n    }\n\n}\n"
    },
    "src/lib/auth/Controlled.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.15;\n\nimport { Owned } from \"./Owned.sol\";\n\n/// @notice Authorization mixin that extends Owned with Controller rol.\nabstract contract Controlled is Owned {\n\n    event ControllerUpdated(address indexed user, address indexed newController);\n\n    address public controller;\n\n    modifier onlyController() virtual {\n        if (msg.sender != controller) revert Unauthorized();\n\n        _;\n    }\n\n    modifier onlyOwnerOrController() virtual {\n        if (msg.sender != owner && msg.sender != controller) revert Unauthorized();\n\n        _;\n    }\n\n    constructor(address owner_, address controller_) Owned(owner_) {\n        controller = controller_;\n\n        emit ControllerUpdated(msg.sender, controller_);\n    }\n\n    function setController(address newController) public virtual onlyOwner {\n        controller = newController;\n\n        emit ControllerUpdated(msg.sender, newController);\n    }\n}\n"
    },
    "src/lib/auth/Owned.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.15;\n\n/// @notice Simple single owner authorization mixin.\n/// @dev Adapted from Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n\n    event OwnerUpdated(address indexed user, address indexed newOwner);\n\n    error Unauthorized();\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        if (msg.sender != owner) revert Unauthorized();\n\n        _;\n    }\n\n    constructor(address owner_) {\n        owner = owner_;\n\n        emit OwnerUpdated(msg.sender, owner_);\n    }\n\n    function setOwner(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnerUpdated(msg.sender, newOwner);\n    }\n}\n\n\n"
    },
  },
  "settings": {
    "remappings": [
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/",
      "murky/=lib/murky/src/",
      "nation3-court/=src/",
      "openzeppelin-contracts/=lib/murky/lib/openzeppelin-contracts/",
      "solmate/=lib/solmate/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 20000
    },
    "metadata": {
      "bytecodeHash": "ipfs"
    },
    "outputSelection": {
      "*": {
        "": [
          "ast"
        ],
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ]
      }
    },
    "evmVersion": "london",
    "libraries": {}
  }
}
